<!DOCTYPE html>
<html lang="cs">
<head>
  
    <title>Hledám cestu k cíly: A* algoritmus :: Jan Malčák</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Označujete svou nadupanou družinu dobrodruhů, přesouváte se na mapě a klikáte na armádu trollů, která bezostyšně útočí na bezbrannou vesnici. Nyní je na vašich hrdinech, aby se rozhodli, kudy (a jestli vůbec ;)) se vydají na cestu. Stejně jako my lidé, budou hledat nejkratší a nejlépe schůdnou cestu k cíli." />
<meta name="keywords" content="astar, dijkstra, manhattan, path, pathfinding, algoritmus, a*, hry" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://jan.malcak.cz/hledam-cestu-k-cily-a-algoritmus/" />




<link rel="stylesheet" href="https://jan.malcak.cz/assets/style.css">






<link rel="apple-touch-icon" href="https://jan.malcak.cz/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://jan.malcak.cz/img/favicon/orange.png">



<meta name="twitter:card" content="summary_large_image" />

  <meta name="twitter:image" content="https://jan.malcak.cz/hledam-cestu-k-cily-a-algoritmus/cover.png">
  
    <meta name="twitter:creator" content="Jan Malčák" />



<meta property="og:locale" content="cs" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Hledám cestu k cíly: A* algoritmus">
<meta property="og:description" content="Označujete svou nadupanou družinu dobrodruhů, přesouváte se na mapě a klikáte na armádu trollů, která bezostyšně útočí na bezbrannou vesnici. Nyní je na vašich hrdinech, aby se rozhodli, kudy (a jestli vůbec ;)) se vydají na cestu. Stejně jako my lidé, budou hledat nejkratší a nejlépe schůdnou cestu k cíli." />
<meta property="og:url" content="https://jan.malcak.cz/hledam-cestu-k-cily-a-algoritmus/" />
<meta property="og:site_name" content="Jan Malčák" />

  <meta property="og:image" content="https://jan.malcak.cz/hledam-cestu-k-cily-a-algoritmus/cover.png">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2012-07-14 15:26:00 &#43;0200 &#43;0200" />










<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>



</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Hlavní stránka
  </div>
</a>

    </div>
    
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://jan.malcak.cz/hledam-cestu-k-cily-a-algoritmus/">Hledám cestu k cíly: A* algoritmus</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2012-07-14
        
      </span>
    
    
      <span class="post-author">:: Jan Malčák</span>
    
    
  </div>

  
  
  <img src="/hledam-cestu-k-cily-a-algoritmus/cover.png"
    class="post-cover"
    alt="Hledám cestu k cíly: A* algoritmus"
    title="Cover Image" />


  

  <div class="post-content"><div>
        <p>V nejjednodušším případě bude mapa jen obyčejná louka, bez jakýchkoli nástrah a překážek. Vaše družina se v takovém případě postupně přesune přímo k cíli po nejkratší možné cestě - přímce. Pro její výpočet může posloužit třeba <a href="http://en.wikipedia.org/wiki/Bresenham's_line_algorithm">Bresenhamův algoritmus (EN)</a>. Pokud by se na cestě přeci jen objevila nějaká překážka, hrdinové by se (pokud programátor při průchodu cesty nebude ignorovat neprůchodná místa) zastavili. Na další cestu by jim takto jednoduchý algoritmus zřejmě nestačil.</p>
<p>Na řešení těchto problémů existuje několik řešení - algoritmů. Mezi ty známější patří například <a href="http://cs.wikipedia.org/wiki/Dijkstr%C5%AFv_algoritmus">Dijkstrův algoritmus</a>. Zjednodušeně řečeno, hledání se šíří na všechny strany od počátečního bodu bez ohledu na to, kterým směrem je cíl. Tak prohledá daleko větší část mapy, než by prohledal, pokud by mířil alespoň přibližným směrem k cíli.</p>

  <figure class="center" >
    <img src="dijkstruv_algoritmus.png"  alt="Dijkstrův algoritmus"   />
    
      <figcaption class="center" >Tmavě zelené pole uprostřed je výchozí. Algoritmus se snažít najít cestu k červenému poli. Výsledná cesta je vyznačena žlutě.</figcaption>
    
  </figure>



  <figure class="center" >
    <img src="a_star_algoritmus.png"  alt="A* algoritmus"   />
    
      <figcaption class="center" >Vyhledávací algoritmus A* naopak míří (alespoň přibližně) k cíli a proto prohledá daleko menší plochu.</figcaption>
    
  </figure>


<h1 id="zjednodušení-vyhledávací-oblasti">Zjednodušení vyhledávací oblasti<a href="#zjednodušení-vyhledávací-oblasti" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Před samotným vyhledáváním je dobré si vyhledávací oblast trochu zjednodušit - rozdělit ji do menších celků. Nejjednodušší je použití čtverců tak, jak to vidíte na obrázkách výše. Krom toho se často využívají <a href="http://en.wikipedia.org/wiki/Hex_map">hexy (en)</a> (kdo by neznal sérii HoMaM) nebo trojúhelníků. Je ale jen na vás, jaký tvar využijete.</p>
<p><strong>Poznámka:</strong> Pro jakýkoliv tvar, do kterého se oblast zjednoduší se v angličtině užívá pojem <strong>node</strong>. V tomto článku budu krom toho používat také pojem pole, který bude znamenat to samé.</p>
<p><strong>Technická poznámka:</strong> Díky rozdělení do čtverců - nodů, je velice jednoduché vytvořit 2D mapu z dlaždic (anglicky tiles). Postačí dvourozměrné pole.</p>
<h1 id="otevřený-a-uzavřený-seznam">Otevřený a uzavřený seznam<a href="#otevřený-a-uzavřený-seznam" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Celý princip vyhledávacího algoritmu A* je založen na dvou seznamech - <em>uzavřeném</em> (anglicky closed list) a <em>otevřeném</em> (anglicky opened list). Do <em>uzavřeného</em> se ukládají už prozkoumané nody, ke kterým se už nebudeme vracet. Do <em>otevřeného seznamu</em> se vloží ta pole, která se ještě musí projít.</p>
<h1 id="ohodnocení">Ohodnocení<a href="#ohodnocení" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Stejně jako v reálném světě i na herní mapě nebude všude stejný povrch. Můžou zde být potoky, písčité duny, silnice, neprostupná skaliska atd. Je jasné, že na silnici se nám půjde lépe a rychleji, než v potoku nebo po skalním masivu. Proto je dobré do mapy zavést ohodnocení jednotlivých políček. Čim lepší a rychlejší schůdnost, tím menší ohodnocení. Podle této analogie bude mít silnice ohodnocení nejmenší a skály největší. Vaše postavy si pak budou moci jednoduše vybrat cestu, která bude tvořená nody s nejmenším ohodnocením. Taková cesta pro ně bude nejrychlejší a nejsnazší.</p>
<p>V A* pathfindingu se na ohodnocení jednotlivých polí používá následující vzorec:</p>
<p>\[ F = H + G \]</p>
<ul>
<li>$ G $ je součet $ G $ jednotlivých nodů, ze kterých je tvořena nejkratší možná cesta ze startovního pole do toho aktuálního</li>
<li>$ H $ je odhadovaná vzdálenost od aktuálního pole do cíle.</li>
<li>$ F $ je součet předchozích dvou hodnot. Výsledná cesta se skládá z nodů, které mají toto číslo nejmenší.</li>
</ul>
<p>Pokud budete ve vzorci chtít použít i ohodnocení terénu (voda, bažiny, cesta, hory), vzorec může vypadat nějak následovně:</p>
<p>\[ F = \Big(H + (T + G)\Big) \]</p>
<ul>
<li>$ T $ zastupuje průchodnost aktuálního terénu (čim nižší hodnota, tím lepší průchodnost).</li>
</ul>
<h2 id="výpočet-hodnoty-g">Výpočet hodnoty G<a href="#výpočet-hodnoty-g" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Hodnota $ G $ se počítá jako součet hodnot $ G $ všech políček, kterými musíte projít, abyste se na aktuální políčko mohli dostat. Například z prvního pole ($ G = 0 $) přejdete na druhé ($ G = 5 $), třetí ($ G=10 $) atd. $ G $ aktuálního pole se vypočítá z $ G $ rodičovského node (odkud jsme na aktuální node přišli) + korekce.</p>
<h3 id="korekce-diagonálního-pohybu">Korekce diagonálního pohybu<a href="#korekce-diagonálního-pohybu" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Při ohodnocování jednotlivých políček můžete narazit na jeden problém. Pokud se postavy přesunou o políčko umístěné šikmo od aktuálního, urazí větší vzdálenost, než kdyby šly vodorovně nebo svisle. Tato hodnota je přesně $ \sqrt{2} $ (=1,414213562) krát větší. Aby se nemuselo počítat s desetinnými čísly (operace s desetinnými čísly jsou obecně pomalejší než s celými čísly), zaokrouhlíme hodnotu na 1,4 a vynásobíme deseti. Vyjde nám číslo 14. To budeme přičítat při pohybu šikmo. Aby zůstalo ohodnocení vyrovnané i pro pohyb vodorovně a svisle (šikmá políčka by vždy měla podstatně větší ohodnocení a proto by se nikdy nepoužila.) bude se při tomto pohybu přičítat číslo 10.</p>
<p><strong>Poznámka:</strong> Číslo deset vzniklo z poměru délky cesty vodorovně nebo svisle a délky cesty šikmo. Základní poměr je 1:1,414213562. Protože nechceme počítat s desetinnými čísly (důvod je popsán výše), zaokrouhlíme poměr na jedno desetinné číslo 1 ku 1,4 a vynásobíme 10. Vznikne poměr 10:14. Samozřejmě je možné čísla ještě vydělit dvěma (vyjdou nám čísla 5 a 7), aby nevycházela tak vysoká čísla.</p>
<h2 id="výpočet-hodnoty-h">Výpočet hodnoty H<a href="#výpočet-hodnoty-h" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Hodnota $ H $ není před vytvořením finální cesty nikdy přesně známá. Proto se tato hodnota vypočítává heuresticky (=odhadem). Dopředu totiž nevíte, zda se v cestě neobjeví neprostupná skála, příliš divoká řeka nebo bezedná jáma. Pro tento výpočet existuje několik možných postupů, zde uvedu dva nejznámější.</p>
<p><strong>Poznámka:</strong> Pokud by hodnota $ H $ byla rovna nule, algoritmus by se proměnil v <a href="http://cs.wikipedia.org/wiki/Dijkstr%C5%AFv_algoritmus">Dijkstrův</a>.</p>
<h3 id="manhattanská-metrika">Manhattanská metrika<a href="#manhattanská-metrika" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Manhattanská metrika je postup, kterým lze zjistit nejkratší možnou vzdálenost z bodu $ A $ do bodu $ B $. Zjednodušený vzorec pro dva body:</p>
<p>\[ H = T \cdot \Big( |start.X - cil.X| + |start.Y - cil.Y| \Big) \]</p>
<p>$ X $ a $ Y $ jsou souřadnice startu a cíle. Podmínkou použití Manhattanské metriky je, že se pohybujete ve čtvercové síti a to jen do čtyř hlavních směrů - nahoru, doprava, dolů a doleva. Písmeno $ T $ reprezentuje nejmenší ohodnocení terénu.</p>
<p><strong>Poznámka:</strong> Manhattanskou metriku je jednoduše možné použít i pro <a href="http://3dmdesign.com/development/hexmap-coordinates-the-easy-way">hexagonální mapu (EN)</a>. Není tedy nutné používat zrovna čtvercovou síť.</p>

  <figure class="center" >
    <img src="start_a_cil.png"  alt="Start a cíl"   />
    
      <figcaption class="center" >Start a cíl</figcaption>
    
  </figure>


<p>Na obrázku jsou dvě pole, start (zelené) a cíl (červené). Vzdálenost mezi těmito dvěma body Manhattanskou metrikou vypočítá následovně:</p>
<p>\[ H = |6 - 2| + |2 - 9| = 11 \]</p>
<p>Manhattanská metrika má ale jednu hlavní nevýhodu. Tou je její omezení pohybu na čtyři hlavní směry.</p>
<h3 id="chebyshevova-vzdálenost-diagonální-pohyb">Chebyshevova vzdálenost (Diagonální pohyb)<a href="#chebyshevova-vzdálenost-diagonální-pohyb" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Pokud chcete postavám umožnit i diagonální pohyb, je potřeba vzore trochu upravit:</p>
<p>\[ dx = |start.x - cil.x| \]
\[ dy = |start.y - cil.y| \]</p>
<p>\[ H = D \cdot max(dx + dy) \]</p>
<p>Pokud používáte korekci pro pohyb diagonálně, použijte tento vzorec:</p>
<p>\[ H = D_1 \cdot (dx + dy) + (D_2 - 2 * D_1) \cdot min(dx, dy) \]</p>
<p>Čísla $ D_1 $ a $ D_2 $ je nutné nahradit za korekci pohybu diagonálně. Např. $ D_1 = 5 $ a $ D_2 = 7 $</p>
<h1 id="vyhledávací-algoritmus-a">Vyhledávací algoritmus A*<a href="#vyhledávací-algoritmus-a" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Konečně nastala ta pravá chvíle, aby jsme si ukázali, jak tento vyhledávací algoritmus funguje v akci. Začneme vybráním startovního (zelený čtvereček) a cílového (červený čtvereček) pole. Šedivá pole jsou neprostupná.</p>
<h2 id="pohyb-ve-čtyřech-směrech">Pohyb ve čtyřech směrech<a href="#pohyb-ve-čtyřech-směrech" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Nejprve si ukážeme pohyb ve čtyřech hlavních směrech - nahoru, doprava, dolů a doleva. Jako heuristika nám v tomto případě bohatě poslouží Manhattanská metrika.</p>
<p><strong>Poznámka:</strong> V tomto případě nemusíte používat opravu pro pohyb šikmo. Jako cenu přechodu tak můžeme použít číslo 1.</p>

  <figure class="center" >
    <img src="algoritmus_01.png"  alt="První krok"   />
    
      <figcaption class="center" >1. krok - Výběr startovního a cílového pole</figcaption>
    
  </figure>


<p>Prvním krokem je výpočet ohodnocení pro startovní pole.</p>
<ul>
<li>$ G = 0 $ – Startovní pole je první node, neušli jsme zatím žádnou cestu.</li>
<li>$ H = 1 \cdot \Big( |2 - 10| + |4 – 2| \Big) = 10 $</li>
<li>$ F = 0 + 10 = 10 $</li>
</ul>
<p>Když má pole své ohodnocení, můžeme ho přidat na otevřený seznam. Z otevřeného seznamu vybereme node s nejnižším $ F $ – protože na otevřeném seznamu je aktuálně jen jeden node, je jasné, který to bude – start. Vybraný node (budeme mu pro přehlednost říkat <strong>aktuální</strong>) odebereme z otevřeného seznamu a přidáme do seznamu uzavřeného. Pro všechna sousedící pole (v našem případě jde jen o pole nad, vpravo, pod a vlevo od startu):</p>
<ul>
<li>Pokud je pole na uzavřeném seznamu, budeme ho ignorovat.</li>
<li>Pokud je pole neprostupné, budeme ho ignorovat</li>
<li>Pokud node není na otevřeném seznamu
<ul>
<li>Nastavte tomuto node rodiče na <strong>aktuální</strong> node (start)</li>
<li>Vypočítejte všechny hodnoty, $ G $, $ H $ a $ F $</li>
</ul>
</li>
<li>Pokud sousedící node již je na otevřeném seznamu
<ul>
<li>Zkontrolujte, zda $ G $ sousedícího node je větší než $ G $ aktuálního node + korekce.
<ul>
<li>Pokud hodnota $ G $ souseda je menší než $ G $ aktuálního node + korekce pro přestup z aktuálního na souseda (Například pokud soused má $ G = 20 $, aktuální node $ G = 10 $ a cena přechodu je 5, bude tato podmínka platit.
<ul>
<li>Nastavte rodiče souseda na <strong>aktuální</strong> node a přepočítejte všechny hodnoty ($ G $, $ H $, $ F $). Pokud udržujete otevřený seznam sežazený podle hodnty $ F $, nezapomeňte ho znovu seřadit.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>S hledáním končíme když je cíl na uzavřeném seznamu (cíl byl nalezen) nebo když je otevřený seznam prázdný (cesta neexistuje). Nyní si postup demonstrujeme na obrázku:</p>

  <figure class="center" >
    <img src="algoritmus_02.png"  alt="Druhý krok"   />
    
      <figcaption class="center" >2. krok - Ohodnocení sousedních nodů</figcaption>
    
  </figure>


<p>Na obrázku se objevilo několik nových hodnot. V levém dolním rohu jsou hodnoty $ G $. V pravém dolním rohu je hodnota $ H $. Vypočítaná je pomocí Manhattanské metriky. Poslední a nejdůležitější hodnotou je $ F $, tedy celkové ohodnocení pole, která je vypsána v horním levém rohu.</p>
<p>Algoritmus by normálně vybral pole s nejmenší hodnotou $ F $. Zde jsou taková pole ale dvě. Které z nich vybrat? To je více-méně jedno. Obecně je rychlejší vybrat to pole, které bylo později přidané na otevřený seznam. Další možností je prohledat obě dvě možné cesty a nakonec vybrat tu kratší. Musíte ovšem počítat s vyšší časovou a paměťovou náročností.</p>
<p>Dejme tomu, že vybereme pole napravo od zeleného. Na šedivá pole vstoupit nelze, proto je budeme ignorovat. To samé platí pro výchozí bod (zelený čtverec), který je na uzavřeném seznamu. Zbyla nám dvě pole (nad a pod azurovým polem), pro které musíme vypočítat nové ohodnocení.</p>

  <figure class="center" >
    <img src="algoritmus_03.png"  alt="Třetí krok"   />
    
      <figcaption class="center" >3. krok algoritmu - posunuli jsme se o jedno pole</figcaption>
    
  </figure>


<p>Opět nastal problém, kdy máme dvě stejně ohodnocená pole. Ještě jednou tedy vybereme později přidaný node (tedy ten nad azurovým). Po přesunu zjistíme, že všechna pole jsou buď na uzavřeném seznamu (start, azurové pole), na otevřeném seznamu (pole nad startem) nebo jde o zdi. V úvahu tak připadá jen jedno pole – to nad startem.</p>
<p>Protože již je na otevřeném seznamu, zkontrolujeme, jestli jeho $ G \gt G_aktualni + \text{korekce} $:</p>
<p>\[ 1 \lt 2 + 1 \]</p>
<p>To samozřejmě platí, proto budeme pokračovat, aniž bychom něco měnili. Konečně tedy náš algoritmus nalezl (už od pohledu jasně viditelný) správný směr. Následující postup bude jen opakování již popsaného.</p>

  <figure class="center" >
    <img src="cil_nalezen_manhattan.png"  alt="Manhattanská metrika - Cíl nalezen"   />
    
      <figcaption class="center" >Ukázka cesty za pomocí pohybu do čtyř stran</figcaption>
    
  </figure>


<h2 id="pohyb-ve-více-směrech">Pohyb ve více směrech<a href="#pohyb-ve-více-směrech" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Rozdílů oproti pohybu do čtyř stran je jen několik. Zaprvé, jako heuristika se používá Chebyshevova vzdálenost. Ta vrací lepší výsledky. Zadruhé, je dobré použít korekci pro pohyb diagonálně.</p>

  <figure class="center" >
    <img src="cil_nalezen_chebyshev.png"  alt="Chebyshevova metrika - Cíl nalezen"   />
    
      <figcaption class="center" >Ukázka cesty při využití pohybu do všech stran</figcaption>
    
  </figure>


<h1 id="nevýhody-a">Nevýhody A*<a href="#nevýhody-a" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Stejně tak jako cokoli jiného, i A* pathfinding není dokonalý a má své mouchy. Na velkých mapách může algoritmus vyžadovat velké množství položek v uzavřeném (closed list) i otevřeném (opened list) seznamu. Jejich uložení může zabrat příliš místa, obzvláště, pokud se hledá několik cest souběžně. I kdyby bylo dostatek místa pro uložení, práce s jednotlivými seznamy může být kvůli velkému množství položek neefektivní.</p>

      </div></div>

  

  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "malja" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Po nocích píše Honza</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://jan.malcak.cz/assets/main.js"></script>
<script src="https://jan.malcak.cz/assets/prism.js"></script>







  
</div>

</body>
</html>
